# 参考博客：https://blog.csdn.net/weixin_38391755/article/details/80380786
#
# ================================ MakeFile 基础 ================================
# 基本语法如下：
# 目标文件：依赖文件
# (tab)执行指令集合
# or
# 目标文件：依赖文件;执行指令集合
#
# 如果依赖文件中有任何一个比目标文件新，则执行指令集合
# 如果目标文件有多个，则后边的依赖文件都可以为目标文件所用，可以同时生成多个目标
# 文件
# 如果命令太长，可以使用“\”换行
# 一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。
#
test: test.c
	gcc test.c
# makefile 的自动推导
# 只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一
# 个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c
# 也会被推导出来，于是，我们的makefile再也不用写得这么复杂，所以test的编译指令也
# 可以写成如下格式
# 	test:


# 每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译,
# 一般的风格都是：
# .PHONY : clean
# clean:
# 	-rm edit $(objects)
# .PHONY意思表示clean是一个“伪目标”
# 在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后
# 面的事。不成文的规矩是——“clean从来都是放在文件的最后”，不然会变成make的默认目标

# 三个常用的变量：$@，$^，$<  ：
# $@ -- 目标文件
# $^ -- 所有的依赖文件
# $< -- 第一个依赖文件


# makefile中的变量
# 实际上变量只能存储字符串。
# 定义: 变量名 = “字符串”
# 使用: $(变量名)
# 赋值方式:
#     直接对变量本身进行操作
#          = 递归展开赋值，当对一个变量进行操作时，如果这个变量后面有变化，
#          	 这个变量不会马上赋值，会一直找到最后一次变量，再进行赋值。
#         := 就地展开赋值，当对一个变量进行操作，直接使用这个变量当前的值，
#         	 而不受后面任何变量。
#     在变量的基础上加上东西
#         += 对某个变量的值，进行追加
#         ?= 如果变量没有初始化，则对其初始化


# ================================ MakeFile 总述 ================================
# Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。
# 1. 显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书
# 	 写者明显指出，要生成的文件，文件的依赖文件，生成的命令。
# 2. 隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙
# 	 地简略地书写Makefile，
# 	 这是由make所支持的。
# 3. 变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点
# 	 C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。
# 4. 文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像
# 	 C语言中的include一样；
# 	 另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；
# 	 还有就是定义一个多行的命令。有关这一部分的内容，会在后续的部分中讲述。
# 5. 注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个
# 	 就像C/C++中的“//”一样。
# 	 如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“\#”。

# ========> Makefile的文件名 <========
#    默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、
#    “Makefile”的文件，找到了则解释这个文件。在这三个文件名中，建议使用“Makefile”命名。
#    最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的
#    “makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”
#    这两种默认文件名。
#
#    当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，
#    “Make.AIX”等，如果要指定特定的Makefile，你可以使用make的“-f”和“--file”参数，
#    如：make -f Make.Linux或make --file Make.AIX。

# ========> 引用其它的Makefile <========
# 在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，
# 被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：
# 	include <filename>
# filename可以是当前操作系统shell的文件模式（可以包含路径和通配符）
#
# 在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和可以用一个或多个
# 空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，
# 以及一个变量$(bar)，
# 其包含了e.mk和f.mk，那么，下面的语句：
# 	include foo.make *.mk $(bar)
# 等价于：
# 	include foo.make a.mk b.mk c.mk e.mk f.mk
#
# make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。
# 就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，
# make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个
# 目录下找：
# a.如果make执行时，有使用“-I”或“--include-dir”参数，那么make就会在这个参数所指定的
# 	目录下去寻找
# b.如果目录/include（一般是）/usr/local/bin 或 /usr/include）存在的话，make也会去寻找
#
# 如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。
# 它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，
# 或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理
# 那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：
# 	-include<filename>
# 其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的
# 相关命令是sinclude，其作用和这一个是一样的。
#
# ========> 环境变量MAKEFILES <========
# 如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类
# 似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include
# 不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的
# 文件发现错误，make也会不理。
#
# 但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用
# make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，
# 只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有
# 定义这个变量。
#
#
# ========> make的工作方式 <========
# GNU的make工作时的执行步骤入下：（想来其它的make也是类似）
# 	1.读入所有的Makefile。
# 	2.读入被include的其它Makefile。
# 	3.初始化文件中的变量。
# 	4.推导隐晦规则，并分析所有规则。
# 	5.为所有的目标文件创建依赖关系链。
# 	6.根据依赖关系，决定哪些目标要重新生成。
# 	7.执行生成命令。
# 1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，
# make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，
# 如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。
#
#
# ================================ MakeFile 书写规则 ================================
# 基本的语法规则已经在前边叙述过，在此不做缀叙
#
# ========> 通配符 <========
# make支持三各通配符：“*”，“?”和“[...]”。这是和Unix的B-Shell是相同的。
#
# "~"
# 波浪号（“~”）字符在文件名中也有比较特殊的用途。如果是“~/test”，这就表示当前用户
# 的$HOME目录下的test目录。而“~hchen/test”则表示用户hchen的宿主目录下的test目录。
# （这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS下，用户没有宿主目
# 录，那么波浪号所指的目录则根据环境变量“HOME”而定。
#
# "*"
# 通配符代替了你一系列的文件，如“*.c”表示所以后缀为c的文件。如果文件名中有通配符，
# 可以用转义字符“\”，如“\*”来表示真实的“*”字符。在目标文件、依赖文件、变量中也可
# 以使用通配符。
#
# ========> 文件搜寻 <========
# 当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个
# 路径告诉make，让make在自动去找。
#
# Makefile文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make只
# 会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在
# 当前目录找不到的情况下，到所指定的目录中去找寻文件了。
#	VPATH = src:../headers
# 上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录
# 由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）
#
# 另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），
# 这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为
# 灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方
# 法有三种：
#   1.vpath < pattern> < directories>    为符合模式< pattern>的文件指定搜索目录<directories>。
#   2.vpath < pattern>                   清除符合模式< pattern>的文件的搜索目录。
#   3.vpath                              清除所有已被设置好了的文件搜索目录
# 其中<pattern>需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有
# 以“.h”结尾的文件。<pattern>指定了要搜索的文件集，而<directories>则指定了的文件
# 集的搜索的目录。例如：
# 	vpath %.h ../headers
# 可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的
# <pattern>，或是被重复了的< pattern>，那么，make会按照vpath语句的先后顺序来执行
# 搜索。如：
#    vpath %.c foo
#    vpath %   blish
#    vpath %.c bar
# 其表示“.c”结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。
#    vpath %.c foo:bar
#    vpath %   blish
# 而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。
#
#
#
# ========> 伪目标 <========
# “伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。
# 当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地
# 指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。
# 	.PHONY : clean
# 只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，执行“make clean”
# 即可。
#
# 伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样
# 可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果需要一口气生成若干
# 可执行文件，但只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，
# 那么可以使用“伪目标”这个特性：
# 	all : prog1 prog2 prog3
# 	.PHONY : all
#
# 	prog1 : prog1.o utils.o
# 		cc -o prog1 prog1.o utils.o
#
# 	prog2 : prog2.o
# 		cc -o prog2 prog2.o
#
# 	prog3 : prog3.o sort.o utils.o
# 		cc -o prog3 prog3.o sort.o utils.o
#
# 由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。
# 所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。
#
#
# 伪目标同样也可成为依赖，举例如下：
#	.PHONY: cleanall cleanobj cleandiff
#
#	cleanall: cleanobj cleandiff
#		rm program
#
#	cleanobj:
#		rm *.o
#
#	cleandiff:
#		rm *.diff
#
# ========> 多目标 <========
#
#

