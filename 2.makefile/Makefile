

# 参考博客：https://blog.csdn.net/weixin_38391755/article/details/80380786
#
# ================================ MakeFile 基础 ================================
# 基本语法如下：
# 目标文件：依赖文件
# (tab)执行指令集合
# 如果依赖文件中有任何一个比目标文件新，则执行指令集合
# 如果目标文件有多个，则后边的依赖文件都可以为目标文件所用，可以同时生成多个目标文件
#
test: test.c
	gcc test.c
# makefile 的自动推导
# 只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，
# 那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，
# 我们的makefile再也不用写得这么复杂，所以test的编译指令也可以写成如下格式
test:


# 每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译, 一般的风格都是：
# .PHONY : clean
# clean:
# 	-rm edit $(objects)
# .PHONY意思表示clean是一个“伪目标”
# 在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。
# 不成文的规矩是——“clean从来都是放在文件的最后”，不然会变成make的默认目标

# 三个常用的变量：$@，$^，$<  ：
# $@ -- 目标文件
# $^ -- 所有的依赖文件
# $< -- 第一个依赖文件


# makefile中的变量
# 实际上变量只能存储字符串。
# 定义: 变量名 = “字符串”
# 使用: $(变量名)
# 赋值方式:
#     直接对变量本身进行操作
#          = 递归展开赋值，当对一个变量进行操作时，如果这个变量后面有变化，这个变量不会马上赋值，会一直找到最后一次变量，再进行赋值。
#         := 就地展开赋值，当对一个变量进行操作，直接使用这个变量当前的值，而不受后面任何变量。
#     在变量的基础上加上东西
#         += 对某个变量的值，进行追加
#         ?= 如果变量没有初始化，则对其初始化


# ================================ MakeFile 总述 ================================
# Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。
# 1. 显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，
# 	 要生成的文件，文件的依赖文件，生成的命令。
# 2. 隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，
# 	 这是由make所支持的。
# 3. 变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，
# 	 当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。
# 4. 文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；
# 	 另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；
# 	 还有就是定义一个多行的命令。有关这一部分的内容，会在后续的部分中讲述。
# 5. 注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。
# 	 如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“\#”。


